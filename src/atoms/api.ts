/* tslint:disable */
/* eslint-disable */
/**
 * Agent Management API
 * API for managing agents, their templates, and call logs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../util/configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AgentDTO
 */
export interface AgentDTO {
    /**
     * The ID of the agent
     * @type {string}
     * @memberof AgentDTO
     */
    '_id': string;
    /**
     * The name of the agent
     * @type {string}
     * @memberof AgentDTO
     */
    'name': string;
    /**
     * The description of the agent
     * @type {string}
     * @memberof AgentDTO
     */
    'description'?: string;
    /**
     * The organization ID of the agent
     * @type {string}
     * @memberof AgentDTO
     */
    'organization'?: string;
    /**
     * The workflow ID of the agent
     * @type {string}
     * @memberof AgentDTO
     */
    'workflowId'?: string;
    /**
     * The user ID of the user who created the agent
     * @type {string}
     * @memberof AgentDTO
     */
    'createdBy'?: string;
    /**
     * The global knowledge base ID of the agent
     * @type {string}
     * @memberof AgentDTO
     */
    'globalKnowledgeBaseId'?: string;
    /**
     * 
     * @type {AgentDTOLanguage}
     * @memberof AgentDTO
     */
    'language'?: AgentDTOLanguage;
    /**
     * 
     * @type {AgentDTOSynthesizer}
     * @memberof AgentDTO
     */
    'synthesizer'?: AgentDTOSynthesizer;
    /**
     * The LLM model to use for the agent. LLM model will be used to generate the response and take decisions based on the user\'s query.
     * @type {string}
     * @memberof AgentDTO
     */
    'slmModel'?: AgentDTOSlmModelEnum;
    /**
     * The default variables to use for the agent. These variables will be used if no variables are provided when initiating a conversation with the agent.
     * @type {object}
     * @memberof AgentDTO
     */
    'defaultVariables'?: object;
    /**
     * The date and time when the agent was created
     * @type {string}
     * @memberof AgentDTO
     */
    'createdAt'?: string;
    /**
     * The date and time when the agent was last updated
     * @type {string}
     * @memberof AgentDTO
     */
    'updatedAt'?: string;
}

export const AgentDTOSlmModelEnum = {
    ElectronV1: 'electron-v1',
    ElectronV2: 'electron-v2',
    Gpt4oMini: 'gpt-4o-mini'
} as const;

export type AgentDTOSlmModelEnum = typeof AgentDTOSlmModelEnum[keyof typeof AgentDTOSlmModelEnum];

/**
 * The language configuration of the agent
 * @export
 * @interface AgentDTOLanguage
 */
export interface AgentDTOLanguage {
    /**
     * The language of the agent
     * @type {string}
     * @memberof AgentDTOLanguage
     */
    'enabled'?: string;
    /**
     * Whether the agent can switch between languages
     * @type {boolean}
     * @memberof AgentDTOLanguage
     */
    'switching'?: boolean;
    /**
     * The supported languages of the agent
     * @type {Array<string>}
     * @memberof AgentDTOLanguage
     */
    'supported'?: Array<string>;
}
/**
 * The synthesizer (TTS) configuration of the agent
 * @export
 * @interface AgentDTOSynthesizer
 */
export interface AgentDTOSynthesizer {
    /**
     * 
     * @type {AgentDTOSynthesizerVoiceConfig}
     * @memberof AgentDTOSynthesizer
     */
    'voiceConfig'?: AgentDTOSynthesizerVoiceConfig;
    /**
     * 
     * @type {number}
     * @memberof AgentDTOSynthesizer
     */
    'speed'?: number;
    /**
     * The consistency of the synthesizer
     * @type {number}
     * @memberof AgentDTOSynthesizer
     */
    'consistency'?: number;
    /**
     * The similarity of the synthesizer
     * @type {number}
     * @memberof AgentDTOSynthesizer
     */
    'similarity'?: number;
    /**
     * The enhancement of the synthesizer
     * @type {number}
     * @memberof AgentDTOSynthesizer
     */
    'enhancement'?: number;
}
/**
 * The voice configuration of the synthesizer
 * @export
 * @interface AgentDTOSynthesizerVoiceConfig
 */
export interface AgentDTOSynthesizerVoiceConfig {
    /**
     * The model of the synthesizer
     * @type {string}
     * @memberof AgentDTOSynthesizerVoiceConfig
     */
    'model'?: AgentDTOSynthesizerVoiceConfigModelEnum;
    /**
     * The voice ID of the synthesizer.
     * @type {string}
     * @memberof AgentDTOSynthesizerVoiceConfig
     */
    'voiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentDTOSynthesizerVoiceConfig
     */
    'gender'?: AgentDTOSynthesizerVoiceConfigGenderEnum;
}

export const AgentDTOSynthesizerVoiceConfigModelEnum = {
    Waves: 'waves',
    WavesLightningLarge: 'waves_lightning_large',
    WavesLightningLargeVoiceClone: 'waves_lightning_large_voice_clone'
} as const;

export type AgentDTOSynthesizerVoiceConfigModelEnum = typeof AgentDTOSynthesizerVoiceConfigModelEnum[keyof typeof AgentDTOSynthesizerVoiceConfigModelEnum];
export const AgentDTOSynthesizerVoiceConfigGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type AgentDTOSynthesizerVoiceConfigGenderEnum = typeof AgentDTOSynthesizerVoiceConfigGenderEnum[keyof typeof AgentDTOSynthesizerVoiceConfigGenderEnum];

/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ApiResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ApiResponse
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface BadRequestErrorResponse
 */
export interface BadRequestErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BadRequestErrorResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BadRequestErrorResponse
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAgentFromTemplate200Response
 */
export interface CreateAgentFromTemplate200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CreateAgentFromTemplate200Response
     */
    'status'?: boolean;
    /**
     * The ID of the created agent
     * @type {string}
     * @memberof CreateAgentFromTemplate200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface CreateAgentFromTemplateRequest
 */
export interface CreateAgentFromTemplateRequest {
    /**
     * Name of the agent
     * @type {string}
     * @memberof CreateAgentFromTemplateRequest
     */
    'agentName': string;
    /**
     * Description of the agent
     * @type {string}
     * @memberof CreateAgentFromTemplateRequest
     */
    'agentDescription'?: string;
    /**
     * ID of the template to use. You can get the list of templates with their description and id from the /agent/template endpoint.
     * @type {string}
     * @memberof CreateAgentFromTemplateRequest
     */
    'templateId': string;
}
/**
 * 
 * @export
 * @interface CreateAgentRequest
 */
export interface CreateAgentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {CreateAgentRequestLanguage}
     * @memberof CreateAgentRequest
     */
    'language'?: CreateAgentRequestLanguage;
    /**
     * The global knowledge base ID of the agent. You can create a global knowledge base by using the /knowledgebase endpoint and assign it to the agent. The agent will use this knowledge base for its responses.
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'globalKnowledgeBaseId'?: string;
    /**
     * The LLM model to use for the agent. LLM model will be used to generate the response and take decisions based on the user\'s query.
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'slmModel'?: CreateAgentRequestSlmModelEnum;
    /**
     * The default variables to use for the agent. These variables will be used if no variables are provided when initiating a conversation with the agent.
     * @type {object}
     * @memberof CreateAgentRequest
     */
    'defaultVariables'?: object;
    /**
     * The telephony product ID of the agent. This is the product ID of the telephony product that will be used to make the outbound call. You can buy telephone number and assign it to the agent.
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'telephonyProductId'?: string;
}

export const CreateAgentRequestSlmModelEnum = {
    ElectronV1: 'electron-v1',
    ElectronV2: 'electron-v2',
    Gpt4oMini: 'gpt-4o-mini'
} as const;

export type CreateAgentRequestSlmModelEnum = typeof CreateAgentRequestSlmModelEnum[keyof typeof CreateAgentRequestSlmModelEnum];

/**
 * Language configuration for the agent. You can enable or disable language switching for the agent. This will be used to determine the language of the agent.
 * @export
 * @interface CreateAgentRequestLanguage
 */
export interface CreateAgentRequestLanguage {
    /**
     * The language of the agent. You can choose from the list of supported languages.
     * @type {string}
     * @memberof CreateAgentRequestLanguage
     */
    'enabled'?: CreateAgentRequestLanguageEnabledEnum;
    /**
     * Whether to enable language switching for the agent. If enabled, the agent will be able to switch between languages based on the user\'s language.
     * @type {boolean}
     * @memberof CreateAgentRequestLanguage
     */
    'switching'?: boolean;
    /**
     * 
     * @type {CreateAgentRequestLanguageSynthesizer}
     * @memberof CreateAgentRequestLanguage
     */
    'synthesizer'?: CreateAgentRequestLanguageSynthesizer;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguage
     */
    'speed'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguage
     */
    'consistency'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguage
     */
    'similarity'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguage
     */
    'enhancement'?: CreateAgentRequestLanguageEnhancementEnum;
}

export const CreateAgentRequestLanguageEnabledEnum = {
    En: 'en',
    Hi: 'hi'
} as const;

export type CreateAgentRequestLanguageEnabledEnum = typeof CreateAgentRequestLanguageEnabledEnum[keyof typeof CreateAgentRequestLanguageEnabledEnum];
export const CreateAgentRequestLanguageEnhancementEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type CreateAgentRequestLanguageEnhancementEnum = typeof CreateAgentRequestLanguageEnhancementEnum[keyof typeof CreateAgentRequestLanguageEnhancementEnum];

/**
 * Synthesizer configuration for the agent. You can configure the synthesizer to use different voices and models. Currently we support 3 types of models for the synthesizer. Waves, Waves Lightning Large and Waves Lightning Large Voice Clone. You can clone your voice using waves platform https://waves.smallest.ai/voice-clone and use the voiceId for this field and select the model as waves_lightning_large_voice_clone to use your cloned voice. When updating the synthesizer configuration to voice clone model, you have to provide model and voiceId and gender all are required fields but when selecting the model as waves or waves and waves_lightning_large, you have to provide only model field and voiceId.
 * @export
 * @interface CreateAgentRequestLanguageSynthesizer
 */
export interface CreateAgentRequestLanguageSynthesizer {
    /**
     * 
     * @type {CreateAgentRequestLanguageSynthesizerVoiceConfig}
     * @memberof CreateAgentRequestLanguageSynthesizer
     */
    'voiceConfig'?: CreateAgentRequestLanguageSynthesizerVoiceConfig;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguageSynthesizer
     */
    'speed'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguageSynthesizer
     */
    'consistency'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguageSynthesizer
     */
    'similarity'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateAgentRequestLanguageSynthesizer
     */
    'enhancement'?: CreateAgentRequestLanguageSynthesizerEnhancementEnum;
}

export const CreateAgentRequestLanguageSynthesizerEnhancementEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type CreateAgentRequestLanguageSynthesizerEnhancementEnum = typeof CreateAgentRequestLanguageSynthesizerEnhancementEnum[keyof typeof CreateAgentRequestLanguageSynthesizerEnhancementEnum];

/**
 * @type CreateAgentRequestLanguageSynthesizerVoiceConfig
 * @export
 */
export type CreateAgentRequestLanguageSynthesizerVoiceConfig = UpdateAgentRequestSynthesizerVoiceConfigOneOf | UpdateAgentRequestSynthesizerVoiceConfigOneOf1;

/**
 * 
 * @export
 * @interface CreateCampaign201Response
 */
export interface CreateCampaign201Response {
    /**
     * 
     * @type {boolean}
     * @memberof CreateCampaign201Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {CreateCampaign201ResponseData}
     * @memberof CreateCampaign201Response
     */
    'data'?: CreateCampaign201ResponseData;
}
/**
 * 
 * @export
 * @interface CreateCampaign201ResponseData
 */
export interface CreateCampaign201ResponseData {
    /**
     * The unique identifier for the campaign
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    '_id'?: string;
    /**
     * The name of the campaign
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    'name'?: string;
    /**
     * The description of the campaign
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    'description'?: string;
    /**
     * The ID of the organization
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    'organization'?: string;
    /**
     * The ID of the agent
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    'agentId'?: string;
    /**
     * The ID of the audience
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    'audienceId'?: string;
    /**
     * The number of participants in the campaign
     * @type {number}
     * @memberof CreateCampaign201ResponseData
     */
    'participantsCount'?: number;
    /**
     * The date and time when the campaign was created
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    'createdAt'?: string;
    /**
     * The date and time when the campaign was last updated
     * @type {string}
     * @memberof CreateCampaign201ResponseData
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface CreateCampaignRequest
 */
export interface CreateCampaignRequest {
    /**
     * The name of the campaign
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'name': string;
    /**
     * The description of the campaign
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'description'?: string;
    /**
     * The ID of the audience
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'audienceId': string;
    /**
     * The ID of the agent
     * @type {string}
     * @memberof CreateCampaignRequest
     */
    'agentId': string;
}
/**
 * 
 * @export
 * @interface CreateKnowledgeBase201Response
 */
export interface CreateKnowledgeBase201Response {
    /**
     * 
     * @type {boolean}
     * @memberof CreateKnowledgeBase201Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateKnowledgeBase201Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface CreateKnowledgeBaseRequest
 */
export interface CreateKnowledgeBaseRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateKnowledgeBaseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateKnowledgeBaseRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface DeleteAgent200Response
 */
export interface DeleteAgent200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteAgent200Response
     */
    'status'?: boolean;
}
/**
 * 
 * @export
 * @interface GetAgentById200Response
 */
export interface GetAgentById200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetAgentById200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {AgentDTO}
     * @memberof GetAgentById200Response
     */
    'data'?: AgentDTO;
}
/**
 * 
 * @export
 * @interface GetAgentTemplates200Response
 */
export interface GetAgentTemplates200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetAgentTemplates200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<GetAgentTemplates200ResponseDataInner>}
     * @memberof GetAgentTemplates200Response
     */
    'data'?: Array<GetAgentTemplates200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetAgentTemplates200ResponseDataInner
 */
export interface GetAgentTemplates200ResponseDataInner {
    /**
     * The ID of the agent template
     * @type {string}
     * @memberof GetAgentTemplates200ResponseDataInner
     */
    'id': string;
    /**
     * The name of the agent template
     * @type {string}
     * @memberof GetAgentTemplates200ResponseDataInner
     */
    'name': string;
    /**
     * The description of the agent template
     * @type {string}
     * @memberof GetAgentTemplates200ResponseDataInner
     */
    'description'?: string;
    /**
     * The avatar URL of the agent template
     * @type {string}
     * @memberof GetAgentTemplates200ResponseDataInner
     */
    'avatarUrl'?: string;
    /**
     * The docs url of the agent template
     * @type {string}
     * @memberof GetAgentTemplates200ResponseDataInner
     */
    'referenceUrl'?: string;
    /**
     * The category of the agent template
     * @type {string}
     * @memberof GetAgentTemplates200ResponseDataInner
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface GetAgents200Response
 */
export interface GetAgents200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetAgents200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {GetAgents200ResponseData}
     * @memberof GetAgents200Response
     */
    'data'?: GetAgents200ResponseData;
}
/**
 * 
 * @export
 * @interface GetAgents200ResponseData
 */
export interface GetAgents200ResponseData {
    /**
     * 
     * @type {Array<AgentDTO>}
     * @memberof GetAgents200ResponseData
     */
    'agents'?: Array<AgentDTO>;
    /**
     * Total number of agents
     * @type {number}
     * @memberof GetAgents200ResponseData
     */
    'totalCount'?: number;
    /**
     * Whether there are more agents to fetch
     * @type {boolean}
     * @memberof GetAgents200ResponseData
     */
    'hasMore'?: boolean;
    /**
     * Whether the results are from a search query
     * @type {boolean}
     * @memberof GetAgents200ResponseData
     */
    'isSearchResults'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCampaignById200Response
 */
export interface GetCampaignById200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetCampaignById200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {GetCampaignById200ResponseData}
     * @memberof GetCampaignById200Response
     */
    'data'?: GetCampaignById200ResponseData;
}
/**
 * 
 * @export
 * @interface GetCampaignById200ResponseData
 */
export interface GetCampaignById200ResponseData {
    /**
     * The unique identifier for the campaign
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    '_id'?: string;
    /**
     * The name of the campaign
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'name'?: string;
    /**
     * The description of the campaign
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'description'?: string;
    /**
     * The ID of the organization
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'organization'?: string;
    /**
     * The ID of the agent
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'agentId'?: string;
    /**
     * The ID of the user who created the campaign
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'createdBy'?: string;
    /**
     * The ID of the audience
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'audienceId'?: string;
    /**
     * The number of participants in the campaign
     * @type {number}
     * @memberof GetCampaignById200ResponseData
     */
    'participantsCount'?: number;
    /**
     * The date and time when the campaign was created
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'createdAt'?: string;
    /**
     * The date and time when the campaign was last updated
     * @type {string}
     * @memberof GetCampaignById200ResponseData
     */
    'updatedAt'?: string;
    /**
     * Whether the campaign is in progress
     * @type {boolean}
     * @memberof GetCampaignById200ResponseData
     */
    'isCampaignInProgress'?: boolean;
    /**
     * Whether the campaign is completed
     * @type {boolean}
     * @memberof GetCampaignById200ResponseData
     */
    'isCampaignCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCampaigns200Response
 */
export interface GetCampaigns200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetCampaigns200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<GetCampaigns200ResponseDataInner>}
     * @memberof GetCampaigns200Response
     */
    'data'?: Array<GetCampaigns200ResponseDataInner>;
}
/**
 * 
 * @export
 * @interface GetCampaigns200ResponseDataInner
 */
export interface GetCampaigns200ResponseDataInner {
    /**
     * The unique identifier for the campaign
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInner
     */
    '_id': string;
    /**
     * The name of the campaign
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'name': string;
    /**
     * The description of the campaign
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'description'?: string;
    /**
     * The ID of the organization
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'organization'?: string;
    /**
     * 
     * @type {GetCampaigns200ResponseDataInnerAgent}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'agent'?: GetCampaigns200ResponseDataInnerAgent;
    /**
     * The ID of the user who created the campaign
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'createdBy'?: string;
    /**
     * 
     * @type {GetCampaigns200ResponseDataInnerAudience}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'audience'?: GetCampaigns200ResponseDataInnerAudience;
    /**
     * The number of participants in the campaign
     * @type {number}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'participantsCount'?: number;
    /**
     * The date and time when the campaign was created
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'createdAt'?: string;
    /**
     * The date and time when the campaign was last updated
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'updatedAt'?: string;
    /**
     * Whether the campaign is in progress
     * @type {boolean}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'isCampaignInProgress'?: boolean;
    /**
     * Whether the campaign is completed
     * @type {boolean}
     * @memberof GetCampaigns200ResponseDataInner
     */
    'isCampaignCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface GetCampaigns200ResponseDataInnerAgent
 */
export interface GetCampaigns200ResponseDataInnerAgent {
    /**
     * The ID of the agent
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInnerAgent
     */
    '_id'?: string;
    /**
     * The name of the agent
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInnerAgent
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetCampaigns200ResponseDataInnerAudience
 */
export interface GetCampaigns200ResponseDataInnerAudience {
    /**
     * The ID of the audience
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInnerAudience
     */
    '_id'?: string;
    /**
     * The name of the audience
     * @type {string}
     * @memberof GetCampaigns200ResponseDataInnerAudience
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GetCampaignsRequest
 */
export interface GetCampaignsRequest {
    /**
     * The page number
     * @type {number}
     * @memberof GetCampaignsRequest
     */
    'page'?: number;
    /**
     * The number of items per page
     * @type {number}
     * @memberof GetCampaignsRequest
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface GetConversationLogs200Response
 */
export interface GetConversationLogs200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetConversationLogs200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {GetConversationLogs200ResponseData}
     * @memberof GetConversationLogs200Response
     */
    'data'?: GetConversationLogs200ResponseData;
}
/**
 * 
 * @export
 * @interface GetConversationLogs200ResponseData
 */
export interface GetConversationLogs200ResponseData {
    /**
     * The ID of the conversation
     * @type {string}
     * @memberof GetConversationLogs200ResponseData
     */
    '_id'?: string;
    /**
     * The ID of the conversation
     * @type {string}
     * @memberof GetConversationLogs200ResponseData
     */
    'callId'?: string;
    /**
     * 
     * @type {AgentDTO}
     * @memberof GetConversationLogs200ResponseData
     */
    'agent'?: AgentDTO;
    /**
     * The status of the conversation
     * @type {string}
     * @memberof GetConversationLogs200ResponseData
     */
    'status'?: string;
    /**
     * The duration of the conversation in seconds
     * @type {number}
     * @memberof GetConversationLogs200ResponseData
     */
    'duration'?: number;
    /**
     * The recording URL of the conversation
     * @type {string}
     * @memberof GetConversationLogs200ResponseData
     */
    'recordingUrl'?: string;
    /**
     * The phone number of the caller
     * @type {string}
     * @memberof GetConversationLogs200ResponseData
     */
    'from'?: string;
    /**
     * The phone number of the callee
     * @type {string}
     * @memberof GetConversationLogs200ResponseData
     */
    'to'?: string;
    /**
     * The transcript of the conversation
     * @type {Array<string>}
     * @memberof GetConversationLogs200ResponseData
     */
    'transcript'?: Array<string>;
    /**
     * The average time taken by the TTS to transcribe the conversation
     * @type {number}
     * @memberof GetConversationLogs200ResponseData
     */
    'average_transcriber_latency'?: number;
    /**
     * The average time taken by the LLM to respond to the conversation
     * @type {number}
     * @memberof GetConversationLogs200ResponseData
     */
    'average_agent_latency'?: number;
    /**
     * The average time taken by the TTS to synthesize the conversation
     * @type {number}
     * @memberof GetConversationLogs200ResponseData
     */
    'average_synthesizer_latency'?: number;
    /**
     * The type of the conversation
     * @type {string}
     * @memberof GetConversationLogs200ResponseData
     */
    'type'?: GetConversationLogs200ResponseDataTypeEnum;
}

export const GetConversationLogs200ResponseDataTypeEnum = {
    TelephonyInbound: 'telephony_inbound',
    TelephonyOutbound: 'telephony_outbound',
    Chat: 'chat'
} as const;

export type GetConversationLogs200ResponseDataTypeEnum = typeof GetConversationLogs200ResponseDataTypeEnum[keyof typeof GetConversationLogs200ResponseDataTypeEnum];

/**
 * 
 * @export
 * @interface GetCurrentUser200Response
 */
export interface GetCurrentUser200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetCurrentUser200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {GetCurrentUser200ResponseData}
     * @memberof GetCurrentUser200Response
     */
    'data'?: GetCurrentUser200ResponseData;
}
/**
 * 
 * @export
 * @interface GetCurrentUser200ResponseData
 */
export interface GetCurrentUser200ResponseData {
    /**
     * The ID of the user
     * @type {string}
     * @memberof GetCurrentUser200ResponseData
     */
    '_id'?: string;
    /**
     * The first name of the user
     * @type {string}
     * @memberof GetCurrentUser200ResponseData
     */
    'firstName'?: string;
    /**
     * The last name of the user
     * @type {string}
     * @memberof GetCurrentUser200ResponseData
     */
    'lastName'?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof GetCurrentUser200ResponseData
     */
    'userEmail'?: string;
    /**
     * The authentication provider of the user
     * @type {string}
     * @memberof GetCurrentUser200ResponseData
     */
    'authProvider'?: string;
    /**
     * Whether the user\'s email is verified
     * @type {boolean}
     * @memberof GetCurrentUser200ResponseData
     */
    'isEmailVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetCurrentUser200ResponseData
     */
    'organizationId'?: string;
}
/**
 * 
 * @export
 * @interface GetKnowledgeBaseById200Response
 */
export interface GetKnowledgeBaseById200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetKnowledgeBaseById200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {KnowledgeBaseDTO}
     * @memberof GetKnowledgeBaseById200Response
     */
    'data'?: KnowledgeBaseDTO;
}
/**
 * 
 * @export
 * @interface GetKnowledgeBaseItems200Response
 */
export interface GetKnowledgeBaseItems200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetKnowledgeBaseItems200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<KnowledgeBaseItemDTO>}
     * @memberof GetKnowledgeBaseItems200Response
     */
    'data'?: Array<KnowledgeBaseItemDTO>;
}
/**
 * 
 * @export
 * @interface GetKnowledgeBases200Response
 */
export interface GetKnowledgeBases200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetKnowledgeBases200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<KnowledgeBaseDTO>}
     * @memberof GetKnowledgeBases200Response
     */
    'data'?: Array<KnowledgeBaseDTO>;
}
/**
 * 
 * @export
 * @interface GetOrganization200Response
 */
export interface GetOrganization200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetOrganization200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {GetOrganization200ResponseData}
     * @memberof GetOrganization200Response
     */
    'data'?: GetOrganization200ResponseData;
}
/**
 * 
 * @export
 * @interface GetOrganization200ResponseData
 */
export interface GetOrganization200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof GetOrganization200ResponseData
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganization200ResponseData
     */
    'name'?: string;
    /**
     * 
     * @type {Array<GetOrganization200ResponseDataMembersInner>}
     * @memberof GetOrganization200ResponseData
     */
    'members'?: Array<GetOrganization200ResponseDataMembersInner>;
    /**
     * 
     * @type {GetOrganization200ResponseDataSubscription}
     * @memberof GetOrganization200ResponseData
     */
    'subscription'?: GetOrganization200ResponseDataSubscription;
}
/**
 * 
 * @export
 * @interface GetOrganization200ResponseDataMembersInner
 */
export interface GetOrganization200ResponseDataMembersInner {
    /**
     * 
     * @type {string}
     * @memberof GetOrganization200ResponseDataMembersInner
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganization200ResponseDataMembersInner
     */
    'userEmail'?: string;
}
/**
 * 
 * @export
 * @interface GetOrganization200ResponseDataSubscription
 */
export interface GetOrganization200ResponseDataSubscription {
    /**
     * 
     * @type {string}
     * @memberof GetOrganization200ResponseDataSubscription
     */
    'planId'?: string;
}
/**
 * 
 * @export
 * @interface InternalServerErrorResponse
 */
export interface InternalServerErrorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof InternalServerErrorResponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalServerErrorResponse
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface KnowledgeBaseDTO
 */
export interface KnowledgeBaseDTO {
    /**
     * The unique identifier for the knowledge base
     * @type {string}
     * @memberof KnowledgeBaseDTO
     */
    '_id': string;
    /**
     * The name of the knowledge base
     * @type {string}
     * @memberof KnowledgeBaseDTO
     */
    'name': string;
    /**
     * Description of the knowledge base
     * @type {string}
     * @memberof KnowledgeBaseDTO
     */
    'description'?: string;
    /**
     * The organization ID this knowledge base belongs to
     * @type {string}
     * @memberof KnowledgeBaseDTO
     */
    'organization': string;
}
/**
 * 
 * @export
 * @interface KnowledgeBaseItemDTO
 */
export interface KnowledgeBaseItemDTO {
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'itemType': KnowledgeBaseItemDTOItemTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof KnowledgeBaseItemDTO
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'knowledgeBaseId': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'processingStatus': KnowledgeBaseItemDTOProcessingStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'contentType'?: string;
    /**
     * 
     * @type {number}
     * @memberof KnowledgeBaseItemDTO
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof KnowledgeBaseItemDTO
     */
    'updatedAt'?: string;
}

export const KnowledgeBaseItemDTOItemTypeEnum = {
    File: 'file',
    Text: 'text'
} as const;

export type KnowledgeBaseItemDTOItemTypeEnum = typeof KnowledgeBaseItemDTOItemTypeEnum[keyof typeof KnowledgeBaseItemDTOItemTypeEnum];
export const KnowledgeBaseItemDTOProcessingStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type KnowledgeBaseItemDTOProcessingStatusEnum = typeof KnowledgeBaseItemDTOProcessingStatusEnum[keyof typeof KnowledgeBaseItemDTOProcessingStatusEnum];

/**
 * 
 * @export
 * @interface StartOutboundCall200Response
 */
export interface StartOutboundCall200Response {
    /**
     * 
     * @type {boolean}
     * @memberof StartOutboundCall200Response
     */
    'status'?: boolean;
    /**
     * 
     * @type {StartOutboundCall200ResponseData}
     * @memberof StartOutboundCall200Response
     */
    'data'?: StartOutboundCall200ResponseData;
}
/**
 * 
 * @export
 * @interface StartOutboundCall200ResponseData
 */
export interface StartOutboundCall200ResponseData {
    /**
     * The ID of the initiated call
     * @type {string}
     * @memberof StartOutboundCall200ResponseData
     */
    'conversationId'?: string;
}
/**
 * 
 * @export
 * @interface StartOutboundCallRequest
 */
export interface StartOutboundCallRequest {
    /**
     * The ID of the agent initiating the conversation
     * @type {string}
     * @memberof StartOutboundCallRequest
     */
    'agentId': string;
    /**
     * The phone number to call
     * @type {string}
     * @memberof StartOutboundCallRequest
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface UnauthorizedErrorReponse
 */
export interface UnauthorizedErrorReponse {
    /**
     * 
     * @type {boolean}
     * @memberof UnauthorizedErrorReponse
     */
    'status'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UnauthorizedErrorReponse
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateAgent200Response
 */
export interface UpdateAgent200Response {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAgent200Response
     */
    'status'?: boolean;
    /**
     * The ID of the updated agent
     * @type {string}
     * @memberof UpdateAgent200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAgentRequest
 */
export interface UpdateAgentRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'description'?: string;
    /**
     * 
     * @type {UpdateAgentRequestLanguage}
     * @memberof UpdateAgentRequest
     */
    'language'?: UpdateAgentRequestLanguage;
    /**
     * 
     * @type {UpdateAgentRequestSynthesizer}
     * @memberof UpdateAgentRequest
     */
    'synthesizer'?: UpdateAgentRequestSynthesizer;
    /**
     * 
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'globalKnowledgeBaseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'slmModel'?: UpdateAgentRequestSlmModelEnum;
    /**
     * The default variables to use for the agent. These variables will be used if no variables are provided when initiating a conversation with the agent.
     * @type {object}
     * @memberof UpdateAgentRequest
     */
    'defaultVariables'?: object;
    /**
     * The telephony product ID of the agent. This is the product ID of the telephony product that will be used to make the outbound call. You can buy telephone number and assign it to the agent.
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'telephonyProductId'?: string;
}

export const UpdateAgentRequestSlmModelEnum = {
    ElectronV1: 'electron-v1',
    ElectronV2: 'electron-v2',
    Gpt4oMini: 'gpt-4o-mini'
} as const;

export type UpdateAgentRequestSlmModelEnum = typeof UpdateAgentRequestSlmModelEnum[keyof typeof UpdateAgentRequestSlmModelEnum];

/**
 * Language configuration for the agent. You can enable or disable language switching for the agent. This will be used to determine the language of the agent.
 * @export
 * @interface UpdateAgentRequestLanguage
 */
export interface UpdateAgentRequestLanguage {
    /**
     * The language of the agent. You can choose from the list of supported languages.
     * @type {string}
     * @memberof UpdateAgentRequestLanguage
     */
    'enabled'?: UpdateAgentRequestLanguageEnabledEnum;
    /**
     * Whether to enable language switching for the agent. If enabled, the agent will be able to switch between languages based on the user\'s language.
     * @type {boolean}
     * @memberof UpdateAgentRequestLanguage
     */
    'switching'?: boolean;
}

export const UpdateAgentRequestLanguageEnabledEnum = {
    En: 'en',
    Hi: 'hi'
} as const;

export type UpdateAgentRequestLanguageEnabledEnum = typeof UpdateAgentRequestLanguageEnabledEnum[keyof typeof UpdateAgentRequestLanguageEnabledEnum];

/**
 * Synthesizer configuration for the agent. You can configure the synthesizer to use different voices and models. Currently we support 3 types of models for the synthesizer. Waves, Waves Lightning Large and Waves Lightning Large Voice Clone. You can clone your voice using waves platform https://waves.smallest.ai/voice-clone and use the voiceId for this field and select the model as waves_lightning_large_voice_clone to use your cloned voice. When updating the synthesizer configuration to voice clone model, you have to provide model and voiceId and gender all are required fields but when selecting the model as waves or waves and waves_lightning_large, you have to provide only model field and voiceId.
 * @export
 * @interface UpdateAgentRequestSynthesizer
 */
export interface UpdateAgentRequestSynthesizer {
    /**
     * 
     * @type {UpdateAgentRequestSynthesizerVoiceConfig}
     * @memberof UpdateAgentRequestSynthesizer
     */
    'voiceConfig'?: UpdateAgentRequestSynthesizerVoiceConfig;
    /**
     * 
     * @type {number}
     * @memberof UpdateAgentRequestSynthesizer
     */
    'speed'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateAgentRequestSynthesizer
     */
    'consistency'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateAgentRequestSynthesizer
     */
    'similarity'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateAgentRequestSynthesizer
     */
    'enhancement'?: UpdateAgentRequestSynthesizerEnhancementEnum;
}

export const UpdateAgentRequestSynthesizerEnhancementEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type UpdateAgentRequestSynthesizerEnhancementEnum = typeof UpdateAgentRequestSynthesizerEnhancementEnum[keyof typeof UpdateAgentRequestSynthesizerEnhancementEnum];

/**
 * @type UpdateAgentRequestSynthesizerVoiceConfig
 * @export
 */
export type UpdateAgentRequestSynthesizerVoiceConfig = UpdateAgentRequestSynthesizerVoiceConfigOneOf | UpdateAgentRequestSynthesizerVoiceConfigOneOf1;

/**
 * 
 * @export
 * @interface UpdateAgentRequestSynthesizerVoiceConfigOneOf
 */
export interface UpdateAgentRequestSynthesizerVoiceConfigOneOf {
    /**
     * We currently support 3 types of models for the synthesizer. Waves, Waves Lightning Large and Waves Lightning Large Voice Clone. You can clone your voice using waves platform and use the voiceId for this field and select the model as waves_lightning_large_voice_clone to use your cloned voice.
     * @type {string}
     * @memberof UpdateAgentRequestSynthesizerVoiceConfigOneOf
     */
    'model'?: UpdateAgentRequestSynthesizerVoiceConfigOneOfModelEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateAgentRequestSynthesizerVoiceConfigOneOf
     */
    'voiceId'?: string;
    /**
     * The gender of the synthesizer. When selecting gender, you have to select the model and voiceId which are required fields.
     * @type {string}
     * @memberof UpdateAgentRequestSynthesizerVoiceConfigOneOf
     */
    'gender'?: UpdateAgentRequestSynthesizerVoiceConfigOneOfGenderEnum;
}

export const UpdateAgentRequestSynthesizerVoiceConfigOneOfModelEnum = {
    WavesLightningLargeVoiceClone: 'waves_lightning_large_voice_clone'
} as const;

export type UpdateAgentRequestSynthesizerVoiceConfigOneOfModelEnum = typeof UpdateAgentRequestSynthesizerVoiceConfigOneOfModelEnum[keyof typeof UpdateAgentRequestSynthesizerVoiceConfigOneOfModelEnum];
export const UpdateAgentRequestSynthesizerVoiceConfigOneOfGenderEnum = {
    Male: 'male',
    Female: 'female'
} as const;

export type UpdateAgentRequestSynthesizerVoiceConfigOneOfGenderEnum = typeof UpdateAgentRequestSynthesizerVoiceConfigOneOfGenderEnum[keyof typeof UpdateAgentRequestSynthesizerVoiceConfigOneOfGenderEnum];

/**
 * 
 * @export
 * @interface UpdateAgentRequestSynthesizerVoiceConfigOneOf1
 */
export interface UpdateAgentRequestSynthesizerVoiceConfigOneOf1 {
    /**
     * We currently support 3 types of models for the synthesizer. Waves, Waves Lightning Large and Waves Lightning Large Voice Clone. You can clone your voice using waves platform and use the voiceId for this field and select the model as waves_lightning_large_voice_clone to use your cloned voice.
     * @type {string}
     * @memberof UpdateAgentRequestSynthesizerVoiceConfigOneOf1
     */
    'model'?: UpdateAgentRequestSynthesizerVoiceConfigOneOf1ModelEnum;
    /**
     * The voice ID to use
     * @type {string}
     * @memberof UpdateAgentRequestSynthesizerVoiceConfigOneOf1
     */
    'voiceId'?: string;
}

export const UpdateAgentRequestSynthesizerVoiceConfigOneOf1ModelEnum = {
    Waves: 'waves',
    WavesLightningLarge: 'waves_lightning_large'
} as const;

export type UpdateAgentRequestSynthesizerVoiceConfigOneOf1ModelEnum = typeof UpdateAgentRequestSynthesizerVoiceConfigOneOf1ModelEnum[keyof typeof UpdateAgentRequestSynthesizerVoiceConfigOneOf1ModelEnum];

/**
 * 
 * @export
 * @interface UploadTextToKnowledgeBaseRequest
 */
export interface UploadTextToKnowledgeBaseRequest {
    /**
     * 
     * @type {string}
     * @memberof UploadTextToKnowledgeBaseRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UploadTextToKnowledgeBaseRequest
     */
    'content': string;
}

/**
 * AgentTemplatesApi - axios parameter creator
 * @export
 */
export const AgentTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * We have created templates for some common use cases. You can use these templates to create an agent. For getting list of templates, you can use the /agent/template endpoint. It will give you the list of templates with their description and id. You can pass the id of the template in the request body to create an agent from the template.
         * @summary Create agent from template
         * @param {CreateAgentFromTemplateRequest} createAgentFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentFromTemplate: async (createAgentFromTemplateRequest: CreateAgentFromTemplateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAgentFromTemplateRequest' is not null or undefined
            assertParamExists('createAgentFromTemplate', 'createAgentFromTemplateRequest', createAgentFromTemplateRequest)
            const localVarPath = `/agent/from-template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAgentFromTemplateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get agent templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agent/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentTemplatesApi - functional programming interface
 * @export
 */
export const AgentTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * We have created templates for some common use cases. You can use these templates to create an agent. For getting list of templates, you can use the /agent/template endpoint. It will give you the list of templates with their description and id. You can pass the id of the template in the request body to create an agent from the template.
         * @summary Create agent from template
         * @param {CreateAgentFromTemplateRequest} createAgentFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgentFromTemplate(createAgentFromTemplateRequest: CreateAgentFromTemplateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentFromTemplate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgentFromTemplate(createAgentFromTemplateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentTemplatesApi.createAgentFromTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get agent templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgentTemplates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentTemplatesApi.getAgentTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentTemplatesApi - factory interface
 * @export
 */
export const AgentTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentTemplatesApiFp(configuration)
    return {
        /**
         * We have created templates for some common use cases. You can use these templates to create an agent. For getting list of templates, you can use the /agent/template endpoint. It will give you the list of templates with their description and id. You can pass the id of the template in the request body to create an agent from the template.
         * @summary Create agent from template
         * @param {CreateAgentFromTemplateRequest} createAgentFromTemplateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentFromTemplate(createAgentFromTemplateRequest: CreateAgentFromTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAgentFromTemplate200Response> {
            return localVarFp.createAgentFromTemplate(createAgentFromTemplateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get agent templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentTemplates(options?: RawAxiosRequestConfig): AxiosPromise<GetAgentTemplates200Response> {
            return localVarFp.getAgentTemplates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentTemplatesApi - object-oriented interface
 * @export
 * @class AgentTemplatesApi
 * @extends {BaseAPI}
 */
export class AgentTemplatesApi extends BaseAPI {
    /**
     * We have created templates for some common use cases. You can use these templates to create an agent. For getting list of templates, you can use the /agent/template endpoint. It will give you the list of templates with their description and id. You can pass the id of the template in the request body to create an agent from the template.
     * @summary Create agent from template
     * @param {CreateAgentFromTemplateRequest} createAgentFromTemplateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentTemplatesApi
     */
    public createAgentFromTemplate(createAgentFromTemplateRequest: CreateAgentFromTemplateRequest, options?: RawAxiosRequestConfig) {
        return AgentTemplatesApiFp(this.configuration).createAgentFromTemplate(createAgentFromTemplateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get agent templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentTemplatesApi
     */
    public getAgentTemplates(options?: RawAxiosRequestConfig) {
        return AgentTemplatesApiFp(this.configuration).getAgentTemplates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You can create a new agent by passing the name of the agent in the request body.
         * @summary Create a new agent
         * @param {CreateAgentRequest} createAgentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent: async (createAgentRequest: CreateAgentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAgentRequest' is not null or undefined
            assertParamExists('createAgent', 'createAgentRequest', createAgentRequest)
            const localVarPath = `/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAgentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an agent
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAgent', 'id', id)
            const localVarPath = `/agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent.
         * @summary Get agent by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAgentById', 'id', id)
            const localVarPath = `/agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent. This API will give you the list of agents created by organization you are a part of.
         * @summary Get all agents
         * @param {number} [page] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents: async (page?: number, offset?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an agent
         * @param {string} id 
         * @param {UpdateAgentRequest} updateAgentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent: async (id: string, updateAgentRequest: UpdateAgentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAgent', 'id', id)
            // verify required parameter 'updateAgentRequest' is not null or undefined
            assertParamExists('updateAgent', 'updateAgentRequest', updateAgentRequest)
            const localVarPath = `/agent/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAgentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * You can create a new agent by passing the name of the agent in the request body.
         * @summary Create a new agent
         * @param {CreateAgentRequest} createAgentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgent(createAgentRequest: CreateAgentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentFromTemplate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgent(createAgentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.createAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an agent
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgent(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.deleteAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent.
         * @summary Get agent by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgentById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.getAgentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent. This API will give you the list of agents created by organization you are a part of.
         * @summary Get all agents
         * @param {number} [page] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgents(page?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgents200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgents(page, offset, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.getAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an agent
         * @param {string} id 
         * @param {UpdateAgentRequest} updateAgentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAgent(id: string, updateAgentRequest: UpdateAgentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAgent(id, updateAgentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.updateAgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * You can create a new agent by passing the name of the agent in the request body.
         * @summary Create a new agent
         * @param {CreateAgentRequest} createAgentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(createAgentRequest: CreateAgentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateAgentFromTemplate200Response> {
            return localVarFp.createAgent(createAgentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an agent
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.deleteAgent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent.
         * @summary Get agent by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAgentById200Response> {
            return localVarFp.getAgentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent. This API will give you the list of agents created by organization you are a part of.
         * @summary Get all agents
         * @param {number} [page] 
         * @param {number} [offset] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(page?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAgents200Response> {
            return localVarFp.getAgents(page, offset, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an agent
         * @param {string} id 
         * @param {UpdateAgentRequest} updateAgentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(id: string, updateAgentRequest: UpdateAgentRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateAgent200Response> {
            return localVarFp.updateAgent(id, updateAgentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * You can create a new agent by passing the name of the agent in the request body.
     * @summary Create a new agent
     * @param {CreateAgentRequest} createAgentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAgent(createAgentRequest: CreateAgentRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).createAgent(createAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an agent
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAgent(id: string, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).deleteAgent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent.
     * @summary Get agent by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAgentById(id: string, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).getAgentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Agents are the main entities in the system. Agents are used to create conversations. You can create workflow for an agent and configure it for different use cases. You can also create custom workflows for an agent. This API will give you the list of agents created by organization you are a part of.
     * @summary Get all agents
     * @param {number} [page] 
     * @param {number} [offset] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAgents(page?: number, offset?: number, search?: string, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).getAgents(page, offset, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an agent
     * @param {string} id 
     * @param {UpdateAgentRequest} updateAgentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateAgent(id: string, updateAgentRequest: UpdateAgentRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).updateAgent(id, updateAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CallsApi - axios parameter creator
 * @export
 */
export const CallsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates an outbound conversation with a specified agent and phone number.
         * @summary Start an outbound call
         * @param {StartOutboundCallRequest} startOutboundCallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startOutboundCall: async (startOutboundCallRequest: StartOutboundCallRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startOutboundCallRequest' is not null or undefined
            assertParamExists('startOutboundCall', 'startOutboundCallRequest', startOutboundCallRequest)
            const localVarPath = `/conversation/outbound`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startOutboundCallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallsApi - functional programming interface
 * @export
 */
export const CallsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CallsApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates an outbound conversation with a specified agent and phone number.
         * @summary Start an outbound call
         * @param {StartOutboundCallRequest} startOutboundCallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startOutboundCall(startOutboundCallRequest: StartOutboundCallRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartOutboundCall200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startOutboundCall(startOutboundCallRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CallsApi.startOutboundCall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CallsApi - factory interface
 * @export
 */
export const CallsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CallsApiFp(configuration)
    return {
        /**
         * Initiates an outbound conversation with a specified agent and phone number.
         * @summary Start an outbound call
         * @param {StartOutboundCallRequest} startOutboundCallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startOutboundCall(startOutboundCallRequest: StartOutboundCallRequest, options?: RawAxiosRequestConfig): AxiosPromise<StartOutboundCall200Response> {
            return localVarFp.startOutboundCall(startOutboundCallRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallsApi - object-oriented interface
 * @export
 * @class CallsApi
 * @extends {BaseAPI}
 */
export class CallsApi extends BaseAPI {
    /**
     * Initiates an outbound conversation with a specified agent and phone number.
     * @summary Start an outbound call
     * @param {StartOutboundCallRequest} startOutboundCallRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallsApi
     */
    public startOutboundCall(startOutboundCallRequest: StartOutboundCallRequest, options?: RawAxiosRequestConfig) {
        return CallsApiFp(this.configuration).startOutboundCall(startOutboundCallRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a campaign
         * @summary Create a campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign: async (createCampaignRequest: CreateCampaignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCampaignRequest' is not null or undefined
            assertParamExists('createCampaign', 'createCampaignRequest', createCampaignRequest)
            const localVarPath = `/campaign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCampaignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a campaign
         * @summary Delete a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaign: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampaign', 'id', id)
            const localVarPath = `/campaign/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a campaign
         * @summary Get a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCampaignById', 'id', id)
            const localVarPath = `/campaign/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all campaigns
         * @summary Retrieve all campaigns
         * @param {GetCampaignsRequest} getCampaignsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaigns: async (getCampaignsRequest: GetCampaignsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getCampaignsRequest' is not null or undefined
            assertParamExists('getCampaigns', 'getCampaignsRequest', getCampaignsRequest)
            const localVarPath = `/campaign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getCampaignsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pause a campaign
         * @summary Pause a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseCampaign: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pauseCampaign', 'id', id)
            const localVarPath = `/campaign/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a campaign
         * @summary Start a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startCampaign', 'id', id)
            const localVarPath = `/campaign/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a campaign
         * @summary Create a campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCampaign201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampaign(createCampaignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.createCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a campaign
         * @summary Delete a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampaign(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampaign(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.deleteCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a campaign
         * @summary Get a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCampaignById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getCampaignById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all campaigns
         * @summary Retrieve all campaigns
         * @param {GetCampaignsRequest} getCampaignsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaigns(getCampaignsRequest: GetCampaignsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCampaigns200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaigns(getCampaignsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.getCampaigns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pause a campaign
         * @summary Pause a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseCampaign(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseCampaign(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.pauseCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a campaign
         * @summary Start a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startCampaign(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startCampaign(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.startCampaign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * Create a campaign
         * @summary Create a campaign
         * @param {CreateCampaignRequest} createCampaignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCampaign201Response> {
            return localVarFp.createCampaign(createCampaignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a campaign
         * @summary Delete a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampaign(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.deleteCampaign(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a campaign
         * @summary Get a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetCampaignById200Response> {
            return localVarFp.getCampaignById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all campaigns
         * @summary Retrieve all campaigns
         * @param {GetCampaignsRequest} getCampaignsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaigns(getCampaignsRequest: GetCampaignsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCampaigns200Response> {
            return localVarFp.getCampaigns(getCampaignsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Pause a campaign
         * @summary Pause a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseCampaign(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.pauseCampaign(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a campaign
         * @summary Start a campaign
         * @param {string} id The ID of the campaign
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startCampaign(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.startCampaign(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI {
    /**
     * Create a campaign
     * @summary Create a campaign
     * @param {CreateCampaignRequest} createCampaignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public createCampaign(createCampaignRequest: CreateCampaignRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).createCampaign(createCampaignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a campaign
     * @summary Delete a campaign
     * @param {string} id The ID of the campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public deleteCampaign(id: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).deleteCampaign(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a campaign
     * @summary Get a campaign
     * @param {string} id The ID of the campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getCampaignById(id: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getCampaignById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all campaigns
     * @summary Retrieve all campaigns
     * @param {GetCampaignsRequest} getCampaignsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public getCampaigns(getCampaignsRequest: GetCampaignsRequest, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).getCampaigns(getCampaignsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pause a campaign
     * @summary Pause a campaign
     * @param {string} id The ID of the campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public pauseCampaign(id: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).pauseCampaign(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a campaign
     * @summary Start a campaign
     * @param {string} id The ID of the campaign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public startCampaign(id: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).startCampaign(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KnowledgeBaseApi - axios parameter creator
 * @export
 */
export const KnowledgeBaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a knowledge base
         * @summary Create a knowledge base
         * @param {CreateKnowledgeBaseRequest} createKnowledgeBaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKnowledgeBase: async (createKnowledgeBaseRequest: CreateKnowledgeBaseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createKnowledgeBaseRequest' is not null or undefined
            assertParamExists('createKnowledgeBase', 'createKnowledgeBaseRequest', createKnowledgeBaseRequest)
            const localVarPath = `/knowledgebase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createKnowledgeBaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a knowledge base
         * @summary Delete a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBase: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKnowledgeBase', 'id', id)
            const localVarPath = `/knowledgebase/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a knowledge base item
         * @summary Delete a knowledge base item
         * @param {string} knowledgeBaseId The ID of the knowledge base
         * @param {string} knowledgeBaseItemId The ID of the knowledge base item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBaseItem: async (knowledgeBaseId: string, knowledgeBaseItemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'knowledgeBaseId' is not null or undefined
            assertParamExists('deleteKnowledgeBaseItem', 'knowledgeBaseId', knowledgeBaseId)
            // verify required parameter 'knowledgeBaseItemId' is not null or undefined
            assertParamExists('deleteKnowledgeBaseItem', 'knowledgeBaseItemId', knowledgeBaseItemId)
            const localVarPath = `/knowledgebase/{knowledgeBaseId}/items/{knowledgeBaseItemId}`
                .replace(`{${"knowledgeBaseId"}}`, encodeURIComponent(String(knowledgeBaseId)))
                .replace(`{${"knowledgeBaseItemId"}}`, encodeURIComponent(String(knowledgeBaseItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a knowledge base
         * @summary Get a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBaseById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKnowledgeBaseById', 'id', id)
            const localVarPath = `/knowledgebase/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all knowledge base items
         * @summary Get all knowledge base items
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBaseItems: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKnowledgeBaseItems', 'id', id)
            const localVarPath = `/knowledgebase/{id}/items`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all knowledge bases
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBases: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/knowledgebase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a media to a knowledge base
         * @summary Upload a media to a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {File} media 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMediaToKnowledgeBase: async (id: string, media: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadMediaToKnowledgeBase', 'id', id)
            // verify required parameter 'media' is not null or undefined
            assertParamExists('uploadMediaToKnowledgeBase', 'media', media)
            const localVarPath = `/knowledgebase/{id}/items/upload-media`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (media !== undefined) { 
                localVarFormParams.append('media', media as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a text to a knowledge base
         * @summary Upload a text to a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {UploadTextToKnowledgeBaseRequest} uploadTextToKnowledgeBaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTextToKnowledgeBase: async (id: string, uploadTextToKnowledgeBaseRequest: UploadTextToKnowledgeBaseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadTextToKnowledgeBase', 'id', id)
            // verify required parameter 'uploadTextToKnowledgeBaseRequest' is not null or undefined
            assertParamExists('uploadTextToKnowledgeBase', 'uploadTextToKnowledgeBaseRequest', uploadTextToKnowledgeBaseRequest)
            const localVarPath = `/knowledgebase/{id}/items/upload-text`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadTextToKnowledgeBaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KnowledgeBaseApi - functional programming interface
 * @export
 */
export const KnowledgeBaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KnowledgeBaseApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a knowledge base
         * @summary Create a knowledge base
         * @param {CreateKnowledgeBaseRequest} createKnowledgeBaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKnowledgeBase(createKnowledgeBaseRequest: CreateKnowledgeBaseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateKnowledgeBase201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKnowledgeBase(createKnowledgeBaseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.createKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a knowledge base
         * @summary Delete a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKnowledgeBase(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKnowledgeBase(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.deleteKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a knowledge base item
         * @summary Delete a knowledge base item
         * @param {string} knowledgeBaseId The ID of the knowledge base
         * @param {string} knowledgeBaseItemId The ID of the knowledge base item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKnowledgeBaseItem(knowledgeBaseId: string, knowledgeBaseItemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKnowledgeBaseItem(knowledgeBaseId, knowledgeBaseItemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.deleteKnowledgeBaseItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a knowledge base
         * @summary Get a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKnowledgeBaseById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKnowledgeBaseById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKnowledgeBaseById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.getKnowledgeBaseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all knowledge base items
         * @summary Get all knowledge base items
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKnowledgeBaseItems(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKnowledgeBaseItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKnowledgeBaseItems(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.getKnowledgeBaseItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all knowledge bases
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKnowledgeBases(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKnowledgeBases200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKnowledgeBases(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.getKnowledgeBases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a media to a knowledge base
         * @summary Upload a media to a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {File} media 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMediaToKnowledgeBase(id: string, media: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMediaToKnowledgeBase(id, media, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.uploadMediaToKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a text to a knowledge base
         * @summary Upload a text to a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {UploadTextToKnowledgeBaseRequest} uploadTextToKnowledgeBaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTextToKnowledgeBase(id: string, uploadTextToKnowledgeBaseRequest: UploadTextToKnowledgeBaseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTextToKnowledgeBase(id, uploadTextToKnowledgeBaseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KnowledgeBaseApi.uploadTextToKnowledgeBase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KnowledgeBaseApi - factory interface
 * @export
 */
export const KnowledgeBaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KnowledgeBaseApiFp(configuration)
    return {
        /**
         * Create a knowledge base
         * @summary Create a knowledge base
         * @param {CreateKnowledgeBaseRequest} createKnowledgeBaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKnowledgeBase(createKnowledgeBaseRequest: CreateKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateKnowledgeBase201Response> {
            return localVarFp.createKnowledgeBase(createKnowledgeBaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a knowledge base
         * @summary Delete a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBase(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.deleteKnowledgeBase(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a knowledge base item
         * @summary Delete a knowledge base item
         * @param {string} knowledgeBaseId The ID of the knowledge base
         * @param {string} knowledgeBaseItemId The ID of the knowledge base item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKnowledgeBaseItem(knowledgeBaseId: string, knowledgeBaseItemId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.deleteKnowledgeBaseItem(knowledgeBaseId, knowledgeBaseItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a knowledge base
         * @summary Get a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBaseById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetKnowledgeBaseById200Response> {
            return localVarFp.getKnowledgeBaseById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all knowledge base items
         * @summary Get all knowledge base items
         * @param {string} id The ID of the knowledge base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBaseItems(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetKnowledgeBaseItems200Response> {
            return localVarFp.getKnowledgeBaseItems(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all knowledge bases
         * @summary Get all knowledge bases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKnowledgeBases(options?: RawAxiosRequestConfig): AxiosPromise<GetKnowledgeBases200Response> {
            return localVarFp.getKnowledgeBases(options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a media to a knowledge base
         * @summary Upload a media to a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {File} media 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMediaToKnowledgeBase(id: string, media: File, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.uploadMediaToKnowledgeBase(id, media, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a text to a knowledge base
         * @summary Upload a text to a knowledge base
         * @param {string} id The ID of the knowledge base
         * @param {UploadTextToKnowledgeBaseRequest} uploadTextToKnowledgeBaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTextToKnowledgeBase(id: string, uploadTextToKnowledgeBaseRequest: UploadTextToKnowledgeBaseRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAgent200Response> {
            return localVarFp.uploadTextToKnowledgeBase(id, uploadTextToKnowledgeBaseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KnowledgeBaseApi - object-oriented interface
 * @export
 * @class KnowledgeBaseApi
 * @extends {BaseAPI}
 */
export class KnowledgeBaseApi extends BaseAPI {
    /**
     * Create a knowledge base
     * @summary Create a knowledge base
     * @param {CreateKnowledgeBaseRequest} createKnowledgeBaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public createKnowledgeBase(createKnowledgeBaseRequest: CreateKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).createKnowledgeBase(createKnowledgeBaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a knowledge base
     * @summary Delete a knowledge base
     * @param {string} id The ID of the knowledge base
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public deleteKnowledgeBase(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).deleteKnowledgeBase(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a knowledge base item
     * @summary Delete a knowledge base item
     * @param {string} knowledgeBaseId The ID of the knowledge base
     * @param {string} knowledgeBaseItemId The ID of the knowledge base item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public deleteKnowledgeBaseItem(knowledgeBaseId: string, knowledgeBaseItemId: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).deleteKnowledgeBaseItem(knowledgeBaseId, knowledgeBaseItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a knowledge base
     * @summary Get a knowledge base
     * @param {string} id The ID of the knowledge base
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public getKnowledgeBaseById(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).getKnowledgeBaseById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all knowledge base items
     * @summary Get all knowledge base items
     * @param {string} id The ID of the knowledge base
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public getKnowledgeBaseItems(id: string, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).getKnowledgeBaseItems(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all knowledge bases
     * @summary Get all knowledge bases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public getKnowledgeBases(options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).getKnowledgeBases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a media to a knowledge base
     * @summary Upload a media to a knowledge base
     * @param {string} id The ID of the knowledge base
     * @param {File} media 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public uploadMediaToKnowledgeBase(id: string, media: File, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).uploadMediaToKnowledgeBase(id, media, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a text to a knowledge base
     * @summary Upload a text to a knowledge base
     * @param {string} id The ID of the knowledge base
     * @param {UploadTextToKnowledgeBaseRequest} uploadTextToKnowledgeBaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeBaseApi
     */
    public uploadTextToKnowledgeBase(id: string, uploadTextToKnowledgeBaseRequest: UploadTextToKnowledgeBaseRequest, options?: RawAxiosRequestConfig) {
        return KnowledgeBaseApiFp(this.configuration).uploadTextToKnowledgeBase(id, uploadTextToKnowledgeBaseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsApi - axios parameter creator
 * @export
 */
export const LogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get conversation logs
         * @param {string} id The callId of the conversation. You can get the callId from the conversation logs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationLogs: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConversationLogs', 'id', id)
            const localVarPath = `/conversation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsApi - functional programming interface
 * @export
 */
export const LogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get conversation logs
         * @param {string} id The callId of the conversation. You can get the callId from the conversation logs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationLogs(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConversationLogs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationLogs(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsApi.getConversationLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsApi - factory interface
 * @export
 */
export const LogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get conversation logs
         * @param {string} id The callId of the conversation. You can get the callId from the conversation logs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationLogs(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GetConversationLogs200Response> {
            return localVarFp.getConversationLogs(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsApi - object-oriented interface
 * @export
 * @class LogsApi
 * @extends {BaseAPI}
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary Get conversation logs
     * @param {string} id The callId of the conversation. You can get the callId from the conversation logs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsApi
     */
    public getConversationLogs(id: string, options?: RawAxiosRequestConfig) {
        return LogsApiFp(this.configuration).getConversationLogs(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganization200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(options?: RawAxiosRequestConfig): AxiosPromise<GetOrganization200Response> {
            return localVarFp.getOrganization(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Get organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganization(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCurrentUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<GetCurrentUser200Response> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Get user details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}



