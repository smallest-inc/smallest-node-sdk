/* tslint:disable */
/* eslint-disable */
/**
 * API Endpoint to interact with Waves API.  
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddVoiceToModel200Response
 */
export interface AddVoiceToModel200Response {
    /**
     * Message if the voice clone was created successfully.
     * @type {string}
     * @memberof AddVoiceToModel200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AddVoiceToModel200ResponseData}
     * @memberof AddVoiceToModel200Response
     */
    'data'?: AddVoiceToModel200ResponseData;
}
/**
 * 
 * @export
 * @interface AddVoiceToModel200ResponseData
 */
export interface AddVoiceToModel200ResponseData {
    /**
     * Unique Voice ID.
     * @type {string}
     * @memberof AddVoiceToModel200ResponseData
     */
    'voiceId': string;
    /**
     * Model used to generate the voice.
     * @type {string}
     * @memberof AddVoiceToModel200ResponseData
     */
    'model': string;
    /**
     * Status of the voice creation.
     * @type {string}
     * @memberof AddVoiceToModel200ResponseData
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface AddVoiceToModel400Response
 */
export interface AddVoiceToModel400Response {
    /**
     * Error type
     * @type {string}
     * @memberof AddVoiceToModel400Response
     */
    'error'?: string;
    /**
     * Error message
     * @type {string}
     * @memberof AddVoiceToModel400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteVoiceClone200Response
 */
export interface DeleteVoiceClone200Response {
    /**
     * Status if the voice clone was deleted successfully.
     * @type {boolean}
     * @memberof DeleteVoiceClone200Response
     */
    'success'?: boolean;
    /**
     * Voice ID of the deleted voice clone.
     * @type {string}
     * @memberof DeleteVoiceClone200Response
     */
    'voiceId': string;
}
/**
 * 
 * @export
 * @interface DeleteVoiceCloneRequest
 */
export interface DeleteVoiceCloneRequest {
    /**
     * The unique identifier of the voice clone to delete.
     * @type {string}
     * @memberof DeleteVoiceCloneRequest
     */
    'voiceId': string;
}
/**
 * 
 * @export
 * @interface GetClonedVoices200Response
 */
export interface GetClonedVoices200Response {
    /**
     * List of available voices.
     * @type {Array<GetClonedVoices200ResponseVoicesInner>}
     * @memberof GetClonedVoices200Response
     */
    'voices'?: Array<GetClonedVoices200ResponseVoicesInner>;
}
/**
 * 
 * @export
 * @interface GetClonedVoices200ResponseVoicesInner
 */
export interface GetClonedVoices200ResponseVoicesInner {
    /**
     * Display name for the voice.
     * @type {string}
     * @memberof GetClonedVoices200ResponseVoicesInner
     */
    'displayName': string;
    /**
     * Accent of the voice.
     * @type {string}
     * @memberof GetClonedVoices200ResponseVoicesInner
     */
    'accent'?: string;
    /**
     * List of tags associated with the voice.
     * @type {Array<string>}
     * @memberof GetClonedVoices200ResponseVoicesInner
     */
    'tags'?: Array<string>;
    /**
     * Unique Voice ID.
     * @type {string}
     * @memberof GetClonedVoices200ResponseVoicesInner
     */
    'voiceId': string;
    /**
     * Model used to generate the voice.
     * @type {string}
     * @memberof GetClonedVoices200ResponseVoicesInner
     */
    'model'?: string;
    /**
     * Status of the voice generation.
     * @type {string}
     * @memberof GetClonedVoices200ResponseVoicesInner
     */
    'status'?: string;
    /**
     * Date and time the voice was created.
     * @type {string}
     * @memberof GetClonedVoices200ResponseVoicesInner
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface GetWavesVoices200Response
 */
export interface GetWavesVoices200Response {
    /**
     * List of available voices.
     * @type {Array<GetWavesVoices200ResponseVoicesInner>}
     * @memberof GetWavesVoices200Response
     */
    'voices'?: Array<GetWavesVoices200ResponseVoicesInner>;
}
/**
 * 
 * @export
 * @interface GetWavesVoices200ResponseVoicesInner
 */
export interface GetWavesVoices200ResponseVoicesInner {
    /**
     * Unique Voice ID.
     * @type {string}
     * @memberof GetWavesVoices200ResponseVoicesInner
     */
    'voiceId': string;
    /**
     * Display name for the voice.
     * @type {string}
     * @memberof GetWavesVoices200ResponseVoicesInner
     */
    'displayName': string;
    /**
     * 
     * @type {GetWavesVoices200ResponseVoicesInnerTags}
     * @memberof GetWavesVoices200ResponseVoicesInner
     */
    'tags'?: GetWavesVoices200ResponseVoicesInnerTags;
}
/**
 * List of tags associated with the voice.
 * @export
 * @interface GetWavesVoices200ResponseVoicesInnerTags
 */
export interface GetWavesVoices200ResponseVoicesInnerTags {
    /**
     * Language of the voice.
     * @type {Array<string>}
     * @memberof GetWavesVoices200ResponseVoicesInnerTags
     */
    'language'?: Array<string>;
    /**
     * Accent of the voice.
     * @type {string}
     * @memberof GetWavesVoices200ResponseVoicesInnerTags
     */
    'accent'?: string;
    /**
     * Gender of the voice.
     * @type {string}
     * @memberof GetWavesVoices200ResponseVoicesInnerTags
     */
    'gender'?: string;
}
/**
 * 
 * @export
 * @interface LightningLargeRequest
 */
export interface LightningLargeRequest {
    /**
     * This parameter controls word repetition and skipping. Decrease it to prevent skipped words, and increase it to prevent repetition.
     * @type {number}
     * @memberof LightningLargeRequest
     */
    'consistency'?: number;
    /**
     * This parameter controls the similarity between the generated speech and the reference audio. Increase it to make the speech more similar to the reference audio.
     * @type {number}
     * @memberof LightningLargeRequest
     */
    'similarity'?: number;
    /**
     * Enhances speech quality at the cost of increased latency.
     * @type {number}
     * @memberof LightningLargeRequest
     */
    'enhancement'?: number;
    /**
     * The text to convert to speech.
     * @type {string}
     * @memberof LightningLargeRequest
     */
    'text': string;
    /**
     * The voice identifier to use for speech generation.
     * @type {string}
     * @memberof LightningLargeRequest
     */
    'voice_id': string;
    /**
     * Whether to add WAV header to the output.
     * @type {boolean}
     * @memberof LightningLargeRequest
     */
    'add_wav_header'?: boolean;
    /**
     * The sample rate for the generated audio.
     * @type {number}
     * @memberof LightningLargeRequest
     */
    'sample_rate'?: number;
    /**
     * The speed of the generated speech.
     * @type {number}
     * @memberof LightningLargeRequest
     */
    'speed'?: number;
    /**
     * Determines how numbers are spelled out. If set to \'en\', numbers will be read as individual digits in English. If set to \'hi\', numbers will be read as individual digits in Hindi.
     * @type {string}
     * @memberof LightningLargeRequest
     */
    'language'?: LightningLargeRequestLanguageEnum;
}

export const LightningLargeRequestLanguageEnum = {
    En: 'en',
    Hi: 'hi',
    Ta: 'ta',
    Fr: 'fr',
    De: 'de',
    Pl: 'pl'
} as const;

export type LightningLargeRequestLanguageEnum = typeof LightningLargeRequestLanguageEnum[keyof typeof LightningLargeRequestLanguageEnum];

/**
 * 
 * @export
 * @interface LightningRequest
 */
export interface LightningRequest {
    /**
     * The text to convert to speech.
     * @type {string}
     * @memberof LightningRequest
     */
    'text': string;
    /**
     * The voice identifier to use for speech generation.
     * @type {string}
     * @memberof LightningRequest
     */
    'voice_id': string;
    /**
     * Whether to add WAV header to the output.
     * @type {boolean}
     * @memberof LightningRequest
     */
    'add_wav_header'?: boolean;
    /**
     * The sample rate for the generated audio.
     * @type {number}
     * @memberof LightningRequest
     */
    'sample_rate'?: number;
    /**
     * The speed of the generated speech.
     * @type {number}
     * @memberof LightningRequest
     */
    'speed'?: number;
    /**
     * Determines how numbers are spelled out. If set to \'en\', numbers will be read as individual digits in English. If set to \'hi\', numbers will be read as individual digits in Hindi.
     * @type {string}
     * @memberof LightningRequest
     */
    'language'?: LightningRequestLanguageEnum;
}

export const LightningRequestLanguageEnum = {
    En: 'en',
    Hi: 'hi',
    Ta: 'ta',
    Fr: 'fr',
    De: 'de',
    Pl: 'pl'
} as const;

export type LightningRequestLanguageEnum = typeof LightningRequestLanguageEnum[keyof typeof LightningRequestLanguageEnum];

/**
 * 
 * @export
 * @interface SynthesizeLightningSpeech400Response
 */
export interface SynthesizeLightningSpeech400Response {
    /**
     * Error type.
     * @type {string}
     * @memberof SynthesizeLightningSpeech400Response
     */
    'error'?: string;
    /**
     * Error message.
     * @type {string}
     * @memberof SynthesizeLightningSpeech400Response
     */
    'message'?: string;
}

/**
 * LightningApi - axios parameter creator
 * @export
 */
export const LightningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Converts provided text to speech using the Lightning model.
         * @summary Generate speech from text (Lightning)
         * @param {LightningRequest} lightningRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizeLightningSpeech: async (lightningRequest: LightningRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lightningRequest' is not null or undefined
            assertParamExists('synthesizeLightningSpeech', 'lightningRequest', lightningRequest)
            const localVarPath = `/api/v1/lightning/get_speech`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lightningRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LightningApi - functional programming interface
 * @export
 */
export const LightningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LightningApiAxiosParamCreator(configuration)
    return {
        /**
         * Converts provided text to speech using the Lightning model.
         * @summary Generate speech from text (Lightning)
         * @param {LightningRequest} lightningRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async synthesizeLightningSpeech(lightningRequest: LightningRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.synthesizeLightningSpeech(lightningRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LightningApi.synthesizeLightningSpeech']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LightningApi - factory interface
 * @export
 */
export const LightningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LightningApiFp(configuration)
    return {
        /**
         * Converts provided text to speech using the Lightning model.
         * @summary Generate speech from text (Lightning)
         * @param {LightningRequest} lightningRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizeLightningSpeech(lightningRequest: LightningRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.synthesizeLightningSpeech(lightningRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LightningApi - object-oriented interface
 * @export
 * @class LightningApi
 * @extends {BaseAPI}
 */
export class LightningApi extends BaseAPI {
    /**
     * Converts provided text to speech using the Lightning model.
     * @summary Generate speech from text (Lightning)
     * @param {LightningRequest} lightningRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningApi
     */
    public synthesizeLightningSpeech(lightningRequest: LightningRequest, options?: RawAxiosRequestConfig) {
        return LightningApiFp(this.configuration).synthesizeLightningSpeech(lightningRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LightningLargeApi - axios parameter creator
 * @export
 */
export const LightningLargeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Converts provided text to speech using the Lightning Large model.
         * @summary Generate speech from text (Lightning Large)
         * @param {LightningLargeRequest} lightningLargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLightningLargeSpeech: async (lightningLargeRequest: LightningLargeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lightningLargeRequest' is not null or undefined
            assertParamExists('streamLightningLargeSpeech', 'lightningLargeRequest', lightningLargeRequest)
            const localVarPath = `/api/v1/lightning-large/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lightningLargeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts provided text to speech using the Lightning Large model.
         * @summary Generate speech from text (Lightning Large)
         * @param {LightningLargeRequest} lightningLargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizeLightningLargeSpeech: async (lightningLargeRequest: LightningLargeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lightningLargeRequest' is not null or undefined
            assertParamExists('synthesizeLightningLargeSpeech', 'lightningLargeRequest', lightningLargeRequest)
            const localVarPath = `/api/v1/lightning-large/get_speech`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lightningLargeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LightningLargeApi - functional programming interface
 * @export
 */
export const LightningLargeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LightningLargeApiAxiosParamCreator(configuration)
    return {
        /**
         * Converts provided text to speech using the Lightning Large model.
         * @summary Generate speech from text (Lightning Large)
         * @param {LightningLargeRequest} lightningLargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLightningLargeSpeech(lightningLargeRequest: LightningLargeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamLightningLargeSpeech(lightningLargeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LightningLargeApi.streamLightningLargeSpeech']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Converts provided text to speech using the Lightning Large model.
         * @summary Generate speech from text (Lightning Large)
         * @param {LightningLargeRequest} lightningLargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async synthesizeLightningLargeSpeech(lightningLargeRequest: LightningLargeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.synthesizeLightningLargeSpeech(lightningLargeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LightningLargeApi.synthesizeLightningLargeSpeech']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LightningLargeApi - factory interface
 * @export
 */
export const LightningLargeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LightningLargeApiFp(configuration)
    return {
        /**
         * Converts provided text to speech using the Lightning Large model.
         * @summary Generate speech from text (Lightning Large)
         * @param {LightningLargeRequest} lightningLargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLightningLargeSpeech(lightningLargeRequest: LightningLargeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.streamLightningLargeSpeech(lightningLargeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Converts provided text to speech using the Lightning Large model.
         * @summary Generate speech from text (Lightning Large)
         * @param {LightningLargeRequest} lightningLargeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        synthesizeLightningLargeSpeech(lightningLargeRequest: LightningLargeRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.synthesizeLightningLargeSpeech(lightningLargeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LightningLargeApi - object-oriented interface
 * @export
 * @class LightningLargeApi
 * @extends {BaseAPI}
 */
export class LightningLargeApi extends BaseAPI {
    /**
     * Converts provided text to speech using the Lightning Large model.
     * @summary Generate speech from text (Lightning Large)
     * @param {LightningLargeRequest} lightningLargeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningLargeApi
     */
    public streamLightningLargeSpeech(lightningLargeRequest: LightningLargeRequest, options?: RawAxiosRequestConfig) {
        return LightningLargeApiFp(this.configuration).streamLightningLargeSpeech(lightningLargeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts provided text to speech using the Lightning Large model.
     * @summary Generate speech from text (Lightning Large)
     * @param {LightningLargeRequest} lightningLargeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningLargeApi
     */
    public synthesizeLightningLargeSpeech(lightningLargeRequest: LightningLargeRequest, options?: RawAxiosRequestConfig) {
        return LightningLargeApiFp(this.configuration).synthesizeLightningLargeSpeech(lightningLargeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoiceCloningApi - axios parameter creator
 * @export
 */
export const VoiceCloningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Instantly clone a voice by uploading an audio file for the specified model.
         * @summary Add a new voice to the model
         * @param {string} displayName Display name for the voice clone.
         * @param {File} file Audio file to create voice clone from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoiceToModel: async (displayName: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayName' is not null or undefined
            assertParamExists('addVoiceToModel', 'displayName', displayName)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('addVoiceToModel', 'file', file)
            const localVarPath = `/api/v1/lightning-large/add_voice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (displayName !== undefined) { 
                localVarFormParams.append('displayName', displayName as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a voice clone associated with the authenticated user.
         * @summary Delete a voice clone
         * @param {DeleteVoiceCloneRequest} deleteVoiceCloneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoiceClone: async (deleteVoiceCloneRequest: DeleteVoiceCloneRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteVoiceCloneRequest' is not null or undefined
            assertParamExists('deleteVoiceClone', 'deleteVoiceCloneRequest', deleteVoiceCloneRequest)
            const localVarPath = `/api/v1/lightning-large`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteVoiceCloneRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch your cloned voices.
         * @summary Get Voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClonedVoices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/lightning-large/get_cloned_voices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoiceCloningApi - functional programming interface
 * @export
 */
export const VoiceCloningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoiceCloningApiAxiosParamCreator(configuration)
    return {
        /**
         * Instantly clone a voice by uploading an audio file for the specified model.
         * @summary Add a new voice to the model
         * @param {string} displayName Display name for the voice clone.
         * @param {File} file Audio file to create voice clone from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVoiceToModel(displayName: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddVoiceToModel200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVoiceToModel(displayName, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceCloningApi.addVoiceToModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a voice clone associated with the authenticated user.
         * @summary Delete a voice clone
         * @param {DeleteVoiceCloneRequest} deleteVoiceCloneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVoiceClone(deleteVoiceCloneRequest: DeleteVoiceCloneRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVoiceClone200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoiceClone(deleteVoiceCloneRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceCloningApi.deleteVoiceClone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch your cloned voices.
         * @summary Get Voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClonedVoices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClonedVoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClonedVoices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoiceCloningApi.getClonedVoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoiceCloningApi - factory interface
 * @export
 */
export const VoiceCloningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoiceCloningApiFp(configuration)
    return {
        /**
         * Instantly clone a voice by uploading an audio file for the specified model.
         * @summary Add a new voice to the model
         * @param {string} displayName Display name for the voice clone.
         * @param {File} file Audio file to create voice clone from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoiceToModel(displayName: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<AddVoiceToModel200Response> {
            return localVarFp.addVoiceToModel(displayName, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a voice clone associated with the authenticated user.
         * @summary Delete a voice clone
         * @param {DeleteVoiceCloneRequest} deleteVoiceCloneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoiceClone(deleteVoiceCloneRequest: DeleteVoiceCloneRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteVoiceClone200Response> {
            return localVarFp.deleteVoiceClone(deleteVoiceCloneRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch your cloned voices.
         * @summary Get Voices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClonedVoices(options?: RawAxiosRequestConfig): AxiosPromise<GetClonedVoices200Response> {
            return localVarFp.getClonedVoices(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoiceCloningApi - object-oriented interface
 * @export
 * @class VoiceCloningApi
 * @extends {BaseAPI}
 */
export class VoiceCloningApi extends BaseAPI {
    /**
     * Instantly clone a voice by uploading an audio file for the specified model.
     * @summary Add a new voice to the model
     * @param {string} displayName Display name for the voice clone.
     * @param {File} file Audio file to create voice clone from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceCloningApi
     */
    public addVoiceToModel(displayName: string, file: File, options?: RawAxiosRequestConfig) {
        return VoiceCloningApiFp(this.configuration).addVoiceToModel(displayName, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a voice clone associated with the authenticated user.
     * @summary Delete a voice clone
     * @param {DeleteVoiceCloneRequest} deleteVoiceCloneRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceCloningApi
     */
    public deleteVoiceClone(deleteVoiceCloneRequest: DeleteVoiceCloneRequest, options?: RawAxiosRequestConfig) {
        return VoiceCloningApiFp(this.configuration).deleteVoiceClone(deleteVoiceCloneRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch your cloned voices.
     * @summary Get Voices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceCloningApi
     */
    public getClonedVoices(options?: RawAxiosRequestConfig) {
        return VoiceCloningApiFp(this.configuration).getClonedVoices(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoicesApi - axios parameter creator
 * @export
 */
export const VoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch voices for a given model.
         * @summary Get Voices
         * @param {GetWavesVoicesModelEnum} model The model to use for speech synthesis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWavesVoices: async (model: GetWavesVoicesModelEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('getWavesVoices', 'model', model)
            const localVarPath = `/api/v1/{model}/get_voices`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoicesApi - functional programming interface
 * @export
 */
export const VoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch voices for a given model.
         * @summary Get Voices
         * @param {GetWavesVoicesModelEnum} model The model to use for speech synthesis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWavesVoices(model: GetWavesVoicesModelEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWavesVoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWavesVoices(model, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoicesApi.getWavesVoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoicesApi - factory interface
 * @export
 */
export const VoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoicesApiFp(configuration)
    return {
        /**
         * Fetch voices for a given model.
         * @summary Get Voices
         * @param {GetWavesVoicesModelEnum} model The model to use for speech synthesis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWavesVoices(model: GetWavesVoicesModelEnum, options?: RawAxiosRequestConfig): AxiosPromise<GetWavesVoices200Response> {
            return localVarFp.getWavesVoices(model, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoicesApi - object-oriented interface
 * @export
 * @class VoicesApi
 * @extends {BaseAPI}
 */
export class VoicesApi extends BaseAPI {
    /**
     * Fetch voices for a given model.
     * @summary Get Voices
     * @param {GetWavesVoicesModelEnum} model The model to use for speech synthesis.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicesApi
     */
    public getWavesVoices(model: GetWavesVoicesModelEnum, options?: RawAxiosRequestConfig) {
        return VoicesApiFp(this.configuration).getWavesVoices(model, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetWavesVoicesModelEnum = {
    Lightning: 'lightning',
    LightningLarge: 'lightning-large'
} as const;
export type GetWavesVoicesModelEnum = typeof GetWavesVoicesModelEnum[keyof typeof GetWavesVoicesModelEnum];


